"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[63649],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>T});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=i,T=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(T,r(r({ref:n},c),{},{components:t})):a.createElement(T,r({ref:n},c))}));function T(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},64025:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const o={title:"CREATE-TABLE",language:"en",toc_min_heading_level:2,toc_max_heading_level:4},r=void 0,l={unversionedId:"sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE",id:"sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE",title:"CREATE-TABLE",description:"\x3c!--",source:"@site/docs/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE.md",sourceDirName:"sql-manual/sql-reference/Data-Definition-Statements/Create",slug:"/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE",permalink:"/docs/dev/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-TABLE",draft:!1,tags:[],version:"current",frontMatter:{title:"CREATE-TABLE",language:"en",toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"docs",previous:{title:"CREATE-EXTERNAL-TABLE",permalink:"/docs/dev/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-EXTERNAL-TABLE"},next:{title:"CREATE-SQL-BLOCK-RULE",permalink:"/docs/dev/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-SQL-BLOCK-RULE"}},s={},p=[{value:"CREATE-TABLE",id:"create-table",level:2},{value:"Description",id:"description",level:3},{value:"column_definition_list",id:"column_definition_list",level:4},{value:"index_definition_list",id:"index_definition_list",level:4},{value:"engine_type",id:"engine_type",level:4},{value:"keys_type",id:"keys_type",level:4},{value:"table_comment",id:"table_comment",level:4},{value:"partition_info",id:"partition_info",level:4},{value:"distribution_desc",id:"distribution_desc",level:4},{value:"rollup_list",id:"rollup_list",level:4},{value:"properties",id:"properties",level:4},{value:"Example",id:"example",level:3},{value:"Keywords",id:"keywords",level:3},{value:"Best Practice",id:"best-practice",level:3},{value:"Partitioning and bucketing",id:"partitioning-and-bucketing",level:4},{value:"Dynamic Partition",id:"dynamic-partition",level:4},{value:"Materialized View",id:"materialized-view",level:4},{value:"Index",id:"index",level:4}],c={toc:p},d="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"create-table"},"CREATE-TABLE"),(0,i.kt)("h3",{id:"description"},"Description"),(0,i.kt)("p",null,"This command is used to create a table. The subject of this document describes the syntax for creating Doris self-maintained tables. For external table syntax, please refer to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/dev/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-EXTERNAL-TABLE"},"CREATE-EXTERNAL-TABLE")," document."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [database.]table\n(\n    column_definition_list,\n    [index_definition_list]\n)\n[engine_type]\n[keys_type]\n[table_comment]\n[partition_info]\ndistribution_desc\n[rollup_list]\n[properties]\n[extra_properties]\n")),(0,i.kt)("h4",{id:"column_definition_list"},"column_definition_list"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Column definition list:\n\n`column_definition[, column_definition]`\n\n* `column_definition`\n\n    Column definition:\n\n    `column_name column_type [KEY] [aggr_type] [NULL] [default_value] [column_comment]`\n\n    * `column_type`\n\n        Column type, the following types are supported:\n\n        ```\n        TINYINT (1 byte)\n            Range: -2^7 + 1 ~ 2^7-1\n        SMALLINT (2 bytes)\n            Range: -2^15 + 1 ~ 2^15-1\n        INT (4 bytes)\n            Range: -2^31 + 1 ~ 2^31-1\n        BIGINT (8 bytes)\n            Range: -2^63 + 1 ~ 2^63-1\n        LARGEINT (16 bytes)\n            Range: -2^127 + 1 ~ 2^127-1\n        FLOAT (4 bytes)\n            Support scientific notation\n        DOUBLE (12 bytes)\n            Support scientific notation\n        DECIMAL[(precision, scale)] (16 bytes)\n            The decimal type with guaranteed precision. The default is DECIMAL(10, 0)\n            precision: 1 ~ 27\n            scale: 0 ~ 9\n            Where the integer part is 1 ~ 18\n            Does not support scientific notation\n        DATE (3 bytes)\n            Range: 0000-01-01 ~ 9999-12-31\n        DATETIME (8 bytes)\n            Range: 0000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n        CHAR[(length)]\n            Fixed-length character string. Length range: 1 ~ 255. Default is 1\n        VARCHAR[(length)]\n            Variable length character string. Length range: 1 ~ 65533. Default is 1\n        HLL (1~16385 bytes)\n            HyperLogLog column type, do not need to specify the length and default value. The length is controlled within the system according to the degree of data aggregation.\n            Must be used with HLL_UNION aggregation type.\n        BITMAP\n            The bitmap column type does not need to specify the length and default value. Represents a collection of integers, and the maximum number of elements supported is 2^64-1.\n            Must be used with BITMAP_UNION aggregation type.\n        ```\n\n    * `aggr_type`\n\n        Aggregation type, the following aggregation types are supported:\n\n        ```\n        SUM: Sum. Applicable numeric types.\n        MIN: Find the minimum value. Suitable for numeric types.\n        MAX: Find the maximum value. Suitable for numeric types.\n        REPLACE: Replace. For rows with the same dimension column, the index column will be imported in the order of import, and the last imported will replace the first imported.\n        REPLACE_IF_NOT_NULL: non-null value replacement. The difference with REPLACE is that there is no replacement for null values. It should be noted here that the default value should be NULL, not an empty string. If it is an empty string, you should replace it with an empty string.\n        HLL_UNION: The aggregation method of HLL type columns, aggregated by HyperLogLog algorithm.\n        BITMAP_UNION: The aggregation mode of BIMTAP type columns, which performs the union aggregation of bitmaps.\n        ```\n\n    * `default_value`\n\n        Default value of the column. If the load data does not specify a value for this column, the system will assign a default value to this column.\n        \n        The syntax is: `default default_value`\u3002\n        \n        Currently, the default value supports two forms:\n\n        1. The user specifies a fixed value, such as:\n\n        ```SQL\n            k1 INT DEFAULT \'1\',\n            k2 CHAR(10) DEFAULT \'aaaa\'\n        ```\n        2. Keywords are provided by the system. Currently, the following keywords are supported: \n        \n        ```SQL\n            // This keyword is used only for DATETIME type. If the value is missing, the system assigns the current timestamp.\n            dt DATETIME DEFAULT CURRENT_TIMESTAMP\n        ```\n\n    Example:\n\n        ```\n        k1 TINYINT,\n        k2 DECIMAL(10,2) DEFAULT "10.5",\n        k4 BIGINT NULL DEFAULT "1000" COMMENT "This is column k4",\n        v1 VARCHAR(10) REPLACE NOT NULL,\n        v2 BITMAP BITMAP_UNION,\n        v3 HLL HLL_UNION,\n        v4 INT SUM NOT NULL DEFAULT "1" COMMENT "This is column v4"\n        ```\n')),(0,i.kt)("h4",{id:"index_definition_list"},"index_definition_list"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Index list definition:\n\n`index_definition[, index_definition]`\n\n* `index_definition`\n\n    Index definition:\n\n    ```sql\n    INDEX index_name (col_name) [USING BITMAP] COMMENT\'xxxxxx\'\n    ```\n\n    Example:\n\n    ```sql\n    INDEX idx1 (k1) USING BITMAP COMMENT "This is a bitmap index1",\n    INDEX idx2 (k2) USING BITMAP COMMENT "This is a bitmap index2",\n    ...\n    ```\n')),(0,i.kt)("h4",{id:"engine_type"},"engine_type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Table engine type. All types in this document are OLAP. For other external table engine types, see [CREATE EXTERNAL TABLE](/docs/dev/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-EXTERNAL-TABLE) document. Example:\n\n`ENGINE=olap`\n")),(0,i.kt)("h4",{id:"keys_type"},"keys_type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Data model.\n\n`key_type(col1, col2, ...)`\n\n`key_type` supports the following models:\n\n* DUPLICATE KEY (default): The subsequent specified column is the sorting column.\n* AGGREGATE KEY: The specified column is the dimension column.\n* UNIQUE KEY: The subsequent specified column is the primary key column.\n\n<version since="2.0">\nNOTE: when set table property `"enable_duplicate_without_keys_by_default" = "true"`, will create a duplicate model without sorting columns and prefix indexes by default.\n</version>\n\nExample:\n\n```\nDUPLICATE KEY(col1, col2),\nAGGREGATE KEY(k1, k2, k3),\nUNIQUE KEY(k1, k2)\n```\n')),(0,i.kt)("h4",{id:"table_comment"},"table_comment"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Table notes. Example:\n\n```\nCOMMENT "This is my first DORIS table"\n```\n')),(0,i.kt)("h4",{id:"partition_info"},"partition_info"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Partition information supports three writing methods:\n\n1. LESS THAN: Only define the upper boundary of the partition. The lower bound is determined by the upper bound of the previous partition.\n\n    ```\n    PARTITION BY RANGE(col1[, col2, ...])\n    (\n        PARTITION partition_name1 VALUES LESS THAN MAXVALUE|("value1", "value2", ...),\n        PARTITION partition_name2 VALUES LESS THAN MAXVALUE|("value1", "value2", ...)\n    )\n    ```\n\n2. FIXED RANGE: Define the left closed and right open interval of the zone.\n\n    ```\n    PARTITION BY RANGE(col1[, col2, ...])\n    (\n        PARTITION partition_name1 VALUES [("k1-lower1", "k2-lower1", "k3-lower1",...), ("k1-upper1", "k2-upper1", "k3-upper1", ... )),\n        PARTITION partition_name2 VALUES [("k1-lower1-2", "k2-lower1-2", ...), ("k1-upper1-2", MAXVALUE, ))\n    )\n    ```\n       \n')),(0,i.kt)("version",{since:"1.2.0"},"3. MULTI RANGE\uff1aMulti build RANGE partitions,Define the left closed and right open interval of the zone, Set the time unit and step size, the time unit supports year, month, day, week and hour.",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    ```\n    PARTITION BY RANGE(col)\n    (\n       FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 1 YEAR,\n       FROM ("2021-11-14") TO ("2022-11-14") INTERVAL 1 MONTH,\n       FROM ("2022-11-14") TO ("2023-01-03") INTERVAL 1 WEEK,\n       FROM ("2023-01-03") TO ("2023-01-14") INTERVAL 1 DAY\n    )\n    ```\n'))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4. MULTI RANGE\uff1aMulti build integer RANGE partitions,Define the left closed and right open interval of the zone, and step size\u3002\n\n    ```\n    PARTITION BY RANGE(int_col)\n    (\n        FROM (1) TO (100) INTERVAL 10\n    )\n    ```\n")),(0,i.kt)("h4",{id:"distribution_desc"},"distribution_desc"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Define the data bucketing method.\n\n1) Hash\n   Syntax:\n   `DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num|auto]`\n   Explain:\n   Hash bucketing using the specified key column.\n2) Random\n   Syntax:\n   `DISTRIBUTED BY RANDOM [BUCKETS num|auto]`\n   Explain:\n   Use random numbers for bucketing.\n")),(0,i.kt)("h4",{id:"rollup_list"},"rollup_list"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Multiple materialized views (ROLLUP) can be created at the same time as the table is built.\n\n`ROLLUP (rollup_definition[, rollup_definition, ...])`\n\n* `rollup_definition`\n\n    `rollup_name (col1[, col2, ...]) [DUPLICATE KEY(col1[, col2, ...])] [PROPERTIES("key" = "value")]`\n\n    Example:\n\n    ```\n    ROLLUP (\n        r1 (k1, k3, v1, v2),\n        r2 (k1, v1)\n    )\n    ```\n')),(0,i.kt)("h4",{id:"properties"},"properties"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Set table properties. The following attributes are currently supported:\n\n* `replication_num`\n\n    Number of copies. The default number of copies is 3. If the number of BE nodes is less than 3, you need to specify that the number of copies is less than or equal to the number of BE nodes.\n    \n    After version 0.15, this attribute will be automatically converted to the `replication_allocation` attribute, such as:\n\n    `"replication_num" = "3"` will be automatically converted to `"replication_allocation" = "tag.location.default:3"`\n\n* `replication_allocation`\n\n     Set the copy distribution according to Tag. This attribute can completely cover the function of the `replication_num` attribute.\n\n* `storage_medium/storage_cooldown_time`\n\n    Data storage medium. `storage_medium` is used to declare the initial storage medium of the table data, and `storage_cooldown_time` is used to set the expiration time. Example:\n\n    ```\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2020-11-20 00:00:00"\n    ```\n\n    This example indicates that the data is stored in the SSD and will be automatically migrated to the HDD storage after the expiration of 2020-11-20 00:00:00.\n\n* `colocate_with`\n\n    When you need to use the Colocation Join function, use this parameter to set the Colocation Group.\n\n    `"colocate_with" = "group1"`\n\n* `bloom_filter_columns`\n\n    The user specifies the list of column names that need to be added to the Bloom Filter index. The Bloom Filter index of each column is independent, not a composite index.\n\n    `"bloom_filter_columns" = "k1, k2, k3"`\n\n* `in_memory`\n\n    Deprecated.\n\n* `function_column.sequence_col`\n\n    When using the UNIQUE KEY model, you can specify a sequence column. When the KEY columns are the same, REPLACE will be performed according to the sequence column (the larger value replaces the smaller value, otherwise it cannot be replaced)\n\n   The `function_column.sequence_col` is used to specify the mapping of the sequence column to a column in the table, which can be integral and time (DATE, DATETIME). The type of this column cannot be changed after creation. If `function_column.sequence_col` is set, `function_column.sequence_type` is ignored.\n\n    `"function_column.sequence_col" =\'column_name\'`\n\n* `function_column.sequence_type`\n\n    When using the UNIQUE KEY model, you can specify a sequence column. When the KEY columns are the same, REPLACE will be performed according to the sequence column (the larger value replaces the smaller value, otherwise it cannot be replaced)\n\n    Here we only need to specify the type of sequence column, support time type or integer type. Doris will create a hidden sequence column.\n\n    `"function_column.sequence_type" =\'Date\'`\n\n* `compression`\n\n    The default compression method for Doris tables is LZ4. After version 1.1, it is supported to specify the compression method as ZSTD to obtain a higher compression ratio.\n\n    `"compression"="zstd"`\n\n* `light_schema_change`\n\n    Whether to use the Light Schema Change optimization.\n    \n    If set to true, the addition and deletion of value columns can be done more quickly and synchronously.\n\n    `"light_schema_change"="true"`\n\n    This feature is enabled by default after v2.0.0.\n\n* `disable_auto_compaction`\n\n    Whether to disable automatic compaction for this table.\n\n    If this property is set to \'true\', the background automatic compaction process will skip all the tables of this table.\n\n    `"disable_auto_compaction" = "false"`\n\n* `enable_single_replica_compaction`\n\n    Whether to enable single replica compaction for this table.\n\n    If this property is set to \'true\', all replicas of the tablet will only have one replica performing compaction, while the others fetch rowsets from that replica.\n\n    `"enable_single_replica_compaction" = "false"`\n\n* `enable_duplicate_without_keys_by_default`\n\n    When `true`, if Unique, Aggregate, or Duplicate is not specified when creating a table, a Duplicate model table without sorting columns and prefix indexes will be created by default.\n\n    `"enable_duplicate_without_keys_by_default" = "false"`\n\n* `skip_write_index_on_load`\n\n    Whether to enable skip inverted index on load for this table.\n\n    If this property is set to \'true\', skip writting index (only inverted index now) on first time load and delay writting \n    index to compaction. It can reduce CPU and IO resource usage for high throughput load.\n\n    `"skip_write_index_on_load" = "false"`\n\n* Dynamic partition related\n\n    The relevant parameters of dynamic partition are as follows:\n\n    * `dynamic_partition.enable`: Used to specify whether the dynamic partition function at the table level is enabled. The default is true.\n    * `dynamic_partition.time_unit:` is used to specify the time unit for dynamically adding partitions, which can be selected as DAY (day), WEEK (week), MONTH (month), YEAR (year), HOUR (hour).\n    * `dynamic_partition.start`: Used to specify how many partitions to delete forward. The value must be less than 0. The default is Integer.MIN_VALUE.\n    * `dynamic_partition.end`: Used to specify the number of partitions created in advance. The value must be greater than 0.\n    * `dynamic_partition.prefix`: Used to specify the partition name prefix to be created. For example, if the partition name prefix is \u200b\u200bp, the partition name will be automatically created as p20200108.\n    * `dynamic_partition.buckets`: Used to specify the number of partition buckets that are automatically created.\n    * `dynamic_partition.create_history_partition`: Whether to create a history partition.\n    * `dynamic_partition.history_partition_num`: Specify the number of historical partitions to be created.\n    * `dynamic_partition.reserved_history_periods`: Used to specify the range of reserved history periods.\n')),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a detailed model table"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    k3 CHAR(10) COMMENT "string column",\n    k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n)\nCOMMENT "my first table"\nDISTRIBUTED BY HASH(k1) BUCKETS 32\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a detailed model table, partition, specify the sorting column, and set the number of copies to 1"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 DATE,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    k3 CHAR(10) COMMENT "string column",\n    k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n)\nDUPLICATE KEY(k1, k2)\nCOMMENT "my first table"\nPARTITION BY RANGE(k1)\n(\n    PARTITION p1 VALUES LESS THAN ("2020-02-01"),\n    PARTITION p2 VALUES LESS THAN ("2020-03-01"),\n    PARTITION p3 VALUES LESS THAN ("2020-04-01")\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_num" = "1"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table with a unique model of the primary key, set the initial storage medium and cooling time"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048),\n    v2 SMALLINT DEFAULT "10"\n)\nUNIQUE KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2) BUCKETS 32\nPROPERTIES(\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an aggregate model table, using a fixed range partition description"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE table_range\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048) REPLACE,\n    v2 INT SUM DEFAULT "1"\n)\nAGGREGATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1, k2, k3)\n(\n    PARTITION p1 VALUES [("2014-01-01", "10", "200"), ("2014-01-01", "20", "300")),\n    PARTITION p2 VALUES [("2014-06-01", "100", "200"), ("2014-07-01", "100", "300"))\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create an aggregate model table with HLL and BITMAP column types"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.example_table\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 HLL HLL_UNION,\n    v2 BITMAP BITMAP_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create two self-maintained tables of the same Colocation Group."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE t1 (\n    id int(11) COMMENT "",\n    value varchar(8) COMMENT ""\n)\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n\nCREATE TABLE t2 (\n    id int(11) COMMENT "",\n    value1 varchar(8) COMMENT "",\n    value2 varchar(8) COMMENT ""\n)\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table with bitmap index and bloom filter index"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM,\n    INDEX k1_idx (k1) USING BITMAP COMMENT\'my first index\'\n)\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "bloom_filter_columns" = "k2"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a dynamic partition table."),(0,i.kt)("p",{parentName:"li"},"The table creates partitions 3 days in advance every day, and deletes the partitions 3 days ago. For example, if today is ",(0,i.kt)("inlineCode",{parentName:"p"},"2020-01-08"),", partitions named ",(0,i.kt)("inlineCode",{parentName:"p"},"p20200108"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"p20200109"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"p20200110"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"p20200111")," will be created. The partition ranges are:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"[types: [DATE]; keys: [2020-01-08]; \u2025types: [DATE]; keys: [2020-01-09];)\n[types: [DATE]; keys: [2020-01-09]; \u2025types: [DATE]; keys: [2020-01-10];)\n[types: [DATE]; keys: [2020-01-10]; \u2025types: [DATE]; keys: [2020-01-11];)\n[types: [DATE]; keys: [2020-01-11]; \u2025types: [DATE]; keys: [2020-01-12];)\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32"\n);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a table with a materialized view (ROLLUP)."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE example_db.rolup_index_table\n(\n    event_day DATE,\n    siteid INT DEFAULT '10',\n    citycode SMALLINT,\n    username VARCHAR(32) DEFAULT'',\n    pv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(event_day, siteid, citycode, username)\nDISTRIBUTED BY HASH(siteid) BUCKETS 10\nROLLUP (\n    r1(event_day,siteid),\n    r2(event_day,citycode),\n    r3(event_day)\n)\nPROPERTIES(\"replication_num\" = \"3\");\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Set the replica of the table through the ",(0,i.kt)("inlineCode",{parentName:"p"},"replication_allocation")," property."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n  k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5"\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_allocation"="tag.location.group_a:1, tag.location.group_b:2"\n);\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32",\n    "dynamic_partition.replication_allocation" = "tag.location.group_a:3"\n );\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Set the table hot and cold separation policy through the ",(0,i.kt)("inlineCode",{parentName:"p"},"storage_policy")," property."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'        CREATE TABLE IF NOT EXISTS create_table_use_created_policy \n        (\n            k1 BIGINT,\n            k2 LARGEINT,\n            v1 VARCHAR(2048)\n        )\n        UNIQUE KEY(k1)\n        DISTRIBUTED BY HASH (k1) BUCKETS 3\n        PROPERTIES(\n            "storage_policy" = "test_create_table_use_policy",\n            "replication_num" = "1"\n        );\n')),(0,i.kt)("p",null,"NOTE: Need to create the s3 resource and storage policy before the table can be successfully associated with the migration policy "),(0,i.kt)("ol",{start:12},(0,i.kt)("li",{parentName:"ol"},"Add a hot and cold data migration strategy for the table partition")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'        CREATE TABLE create_table_partion_use_created_policy\n        (\n            k1 DATE,\n            k2 INT,\n            V1 VARCHAR(2048) REPLACE\n        ) PARTITION BY RANGE (k1) (\n            PARTITION p1 VALUES LESS THAN ("2022-01-01") ("storage_policy" = "test_create_table_partition_use_policy_1" ,"replication_num"="1"),\n            PARTITION p2 VALUES LESS THAN ("2022-02-01") ("storage_policy" = "test_create_table_partition_use_policy_2" ,"replication_num"="1")\n        ) DISTRIBUTED BY HASH(k2) BUCKETS 1;\n')),(0,i.kt)("p",null,"NOTE: Need to create the s3 resource and storage policy before the table can be successfully associated with the migration policy "),(0,i.kt)("version",{since:"1.2.0"},(0,i.kt)("ol",{start:13},(0,i.kt)("li",{parentName:"ol"},"Multi Partition by a partition desc")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'        CREATE TABLE create_table_multi_partion_date\n        (\n            k1 DATE,\n            k2 INT,\n            V1 VARCHAR(20)\n        ) PARTITION BY RANGE (k1) (\n            FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 1 YEAR,\n            FROM ("2021-11-14") TO ("2022-11-14") INTERVAL 1 MONTH,\n            FROM ("2022-11-14") TO ("2023-01-03") INTERVAL 1 WEEK,\n            FROM ("2023-01-03") TO ("2023-01-14") INTERVAL 1 DAY,\n            PARTITION p_20230114 VALUES [(\'2023-01-14\'), (\'2023-01-15\'))\n        ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n        PROPERTIES(\n            "replication_num" = "1"\n        );\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'        CREATE TABLE create_table_multi_partion_date_hour\n        (\n            k1 DATETIME,\n            k2 INT,\n            V1 VARCHAR(20)\n        ) PARTITION BY RANGE (k1) (\n            FROM ("2023-01-03 12") TO ("2023-01-14 22") INTERVAL 1 HOUR\n        ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n        PROPERTIES(\n            "replication_num" = "1"\n        );\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'        CREATE TABLE create_table_multi_partion_integer\n        (\n            k1 BIGINT,\n            k2 INT,\n            V1 VARCHAR(20)\n        ) PARTITION BY RANGE (k1) (\n            FROM (1) TO (100) INTERVAL 10\n        ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n        PROPERTIES(\n            "replication_num" = "1"\n        );\n')),(0,i.kt)("p",null,"NOTE: Multi Partition can be mixed with conventional manual creation of partitions. When using, you need to limit the partition column to only one, The default maximum number of partitions created in multi partition is 4096, This parameter can be adjusted in fe configuration ",(0,i.kt)("inlineCode",{parentName:"p"},"max_multi_partition_num"),".")),(0,i.kt)("version",{since:"2.0"},(0,i.kt)("ol",{start:14},(0,i.kt)("li",{parentName:"ol"},"Add a duplicate without sorting column table")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'    CREATE TABLE example_db.table_hash\n    (\n        k1 DATE,\n        k2 DECIMAL(10, 2) DEFAULT "10.5",\n        k3 CHAR(10) COMMENT "string column",\n        k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n    )\n    COMMENT "duplicate without keys"\n    PARTITION BY RANGE(k1)\n    (\n        PARTITION p1 VALUES LESS THAN ("2020-02-01"),\n        PARTITION p2 VALUES LESS THAN ("2020-03-01"),\n        PARTITION p3 VALUES LESS THAN ("2020-04-01")\n    )\n    DISTRIBUTED BY HASH(k1) BUCKETS 32\n    PROPERTIES (\n        "replication_num" = "1",\n        "enable_duplicate_without_keys_by_default" = "true"\n    );\n'))),(0,i.kt)("h3",{id:"keywords"},"Keywords"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"CREATE, TABLE\n")),(0,i.kt)("h3",{id:"best-practice"},"Best Practice"),(0,i.kt)("h4",{id:"partitioning-and-bucketing"},"Partitioning and bucketing"),(0,i.kt)("p",null,"A table must specify the bucket column, but it does not need to specify the partition. For the specific introduction of partitioning and bucketing, please refer to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/dev/data-table/data-partition"},"Data Division")," document."),(0,i.kt)("p",null,"Tables in Doris can be divided into partitioned tables and non-partitioned tables. This attribute is determined when the table is created and cannot be changed afterwards. That is, for partitioned tables, you can add or delete partitions in the subsequent use process, and for non-partitioned tables, you can no longer perform operations such as adding partitions afterwards."),(0,i.kt)("p",null,"At the same time, partitioning columns and bucketing columns cannot be changed after the table is created. You can neither change the types of partitioning and bucketing columns, nor do any additions or deletions to these columns."),(0,i.kt)("p",null,"Therefore, it is recommended to confirm the usage method to build the table reasonably before building the table."),(0,i.kt)("h4",{id:"dynamic-partition"},"Dynamic Partition"),(0,i.kt)("p",null,"The dynamic partition function is mainly used to help users automatically manage partitions. By setting certain rules, the Doris system regularly adds new partitions or deletes historical partitions. Please refer to ",(0,i.kt)("a",{parentName:"p",href:"/docs/dev/advanced/partition/dynamic-partition"},"Dynamic Partition")," document for more help."),(0,i.kt)("h4",{id:"materialized-view"},"Materialized View"),(0,i.kt)("p",null,"Users can create multiple materialized views (ROLLUP) while building a table. Materialized views can also be added after the table is built. It is convenient for users to create all materialized views at one time by writing in the table creation statement."),(0,i.kt)("p",null,"If the materialized view is created when the table is created, all subsequent data import operations will synchronize the data of the materialized view to be generated. The number of materialized views may affect the efficiency of data import."),(0,i.kt)("p",null,"If you add a materialized view in the subsequent use process, if there is data in the table, the creation time of the materialized view depends on the current amount of data."),(0,i.kt)("p",null,"For the introduction of materialized views, please refer to the document ",(0,i.kt)("a",{parentName:"p",href:"/docs/dev/query-acceleration/materialized-view"},"materialized views"),"."),(0,i.kt)("h4",{id:"index"},"Index"),(0,i.kt)("p",null,"Users can create indexes on multiple columns while building a table. Indexes can also be added after the table is built."),(0,i.kt)("p",null,"If you add an index in the subsequent use process, if there is data in the table, you need to rewrite all the data, so the creation time of the index depends on the current data volume."))}u.isMDXComponent=!0}}]);